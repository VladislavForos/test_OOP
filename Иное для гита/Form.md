#####Форма хранения данных зависит от контекста!#####
Например, возьмем переменную отвечающую за дату события:  
- в базе данных это будет int timestamp  
- в HMTL это будет дата с месяцами прописью  
- на форме это будут числа через точку

Соответственно нам надо этот процесс как то формализовать, что бы им управлять.  
Мы берем одно из состояний как базовое - обычно это то что хранится в базе данных  
далее делаем конвертеры из базового состояния в остальные и обратно (если нужно).

Например:  

* __toHTML__ - вернет в формате вывода
* __toForm__ - понятно 
* __fromHTML__ - не делаем - потому что данные сам HTML не посылает
* __fromForm__ – делаем, потому что данные пришедшие с формы надо привести к базовому для сохранения или что б сконвертировать в HTML и вывести

В общем, если нарисовать диаграмму,  то получится такая звездочка, с базовым состоянием в центре, класс который умеет так конвертировать данные и работает с одним типом данные (строка, число, дата, картинка и т.д.).
  
Такие классы мы называем - __базовые типы__.
  
Реактор в коробке уже имеет штук 10 базовых типов, но можно добавить свои, причем довольно сложные. В принципе, 1 базовый тип может манипулировать и структурой данных - как своим значением - у нас даже есть такие примеры. Но обычно формы состоят не из одного поля соответственно нам нужен управляющий класс, который может манипулировать пачкой базовых типов как одним объектом и, тем самым, например, сразу переконвертировать под нужный контекст объект из нескольких полей с разными типами данных. Соответственно, этот управляющий класс принципиально так же имеет методы – toForm, toHTML, fromForm, toDB и т.д. 

Кроме того, метод fromForm, дополнительно еще валидирует данные и может сделать репорт по данным - какие не соответствуют формату, отсутствуют, поменялись, когда не должны были, установить значение по умолчанию и т.д. 

Работает управляющий класс довольно просто:   
у него есть метод что бы заслать в него структуру данных описывающих с каким объектом мы хотим его использовать  

* набор полей, их имена, их базовый тип, значение по умолчанию, обязательно или нет и т.д.  
* большинство из них, как понятно из названия, используются для валидации  
* для конвертации нужно тока имя поля и имя базового типа  
   
это что касается content_adapter в чистом виде.

Кстати, зная концепцию конвертации данных под разные контексты - лучше понятно почему так называется класс, поскольку класс имеет представление о структуре данных и умеет их валидировть. Он еще используется как объект, представляющий форму:

* что бы рендерить ХТМЛ формы
* что бы валидировать данные
* что бы обеспечивать процесс обработки формы

Процесс работы формы вкратце такой:  
на основе определения интерфейса (он хранит описание структур данных) создается уже сконфигурированный объект контент адаптер
  
1. объект формы или просто форма
2. интерфейс упаковывается в сессию и сохраняется внутри объект формы – да-да родитель как бы сохраняется внутри ребенка
3. объект формы после этого сам сохраняется сессию - потом понятно будет почему 

Каждый раз, когда объект сохраняется в сессию, ему дается идентификатор в сессии по которому его можно вытащить - _so(so значит сессионный объект). Еще важно отметить -  когда мы создаём объект формы - ему также указывается:

* в какой метод интерфейса надо послать результат
* на какой url надо послать человека в случае правильной валидации
* куда в случае CANCEL и типа такого

В коде можно посмотреть, что это происходит в core_api функция createForm, далее объект формы посылается в шаблон форму, где используя его определение формы рендерится форма. Так же с запросом передается so идентификатор пользователя, заполняет форму и запрос уходит на стандартный обработчик форм. Он находить там же в core_api handleForm.

Что в нем происходит:

все начинается с получаения _so, без него не понятно что делать с данным и будет сгенерирована ошибка

1. по СО восстанавливается объект формы - он уже сконфигурирован
2. ему скармливаются данные с формы
3. он их вадилирует - fromForm
4. если все __ОК__ - он восстанавливает по своему внутреннему СО - интерфейс
5. так же он знает на какой екшен интерфейса послать данные- что он и делает
6. екшен интерфейса как то обрабатывает данные(обычно сохранят в базу)
7. иногда он может сделать как бы дополнительную валидацию и т.д.
8. если что-то не так - интерфейс возвращает false. В этом случае пользователь посылается на url который заранее определен в объекте формы для ошибки - обычно это сама страница формы

При валидации форма сохраняет ошибки внутри себя.

__Ошибки__

При рендере формы ты имеешь доступ к объекту формы и ошибкам соответственно, причем хорошие данные сохраняются так же и во внутренние поля формы. Это дает возможность при ошибке возвратить человека на форму и оставить введенным поля, которые нормальные. Соответственно - если обработка интерфейса не вернула false, то пользователь редиректится по url, уоторый указан как положительный (по умолчанию это предыдущая страница он открытия формы).

Сохраненные объекты в сессии удаляются также на этом этапе. На этом обработка формы заканчивается.

То, что она и ее создавший ее интерфейс сохраняется в сессию - позволяет делать динамические структуры данных - когда в интерфейсе определяется базовый набор полей. Но при создании инстанса интерфейса - он сам себя переконфигурирует на набор полей зависящий от ИД объекта. Например: это позволяет объекту описание товара - иметь разный набор полей в зависимости от типа товара.

Екшен обычно вызывает методы своего класса - который он хранит внутри себя, но если прописать метод начинающийся на «_», например,  «_createForm» - то выполнится функция createForm из глобального пространства имен. Соответственно,  если проследить выполнение екшена news=>add (не путать с методом), то можно увидеть все вышеизложенное.

* екшен add у интерфейса вызывает _isForm.
isForm - либо создает форму заново, вызывая указанный екшен (который в свою очередь вызывает createForm), либо восстанавливает форму из SО пришедший в параметрах.Далее объект используется для рендера формы.
* createForm - инициализирует форму на основе интерфейс
* handleForm - обрабатывает форму

